<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Why FaaS &amp; GitOps? — fn-uns Docs</title>
<meta name="description" content="Why we use serverless functions and git push deployments instead of flow builders or monolithic platforms."/>
<link rel="stylesheet" href="../style.css"/>
<link rel="stylesheet" href="../docs.css"/>
</head>
<body>

<nav>
  <a href="/" class="logo">UNS Framework</a>
  <div class="links">
    <a href="/framework/">Standard v1.0</a>
    <a href="/fn-uns/">fn-uns</a>
    <a href="https://github.com/unsframework" target="_blank">GitHub</a>
    <button class="theme-toggle" id="themeToggle" aria-label="Toggle dark mode">
      <div class="toggle-thumb"><span class="toggle-icon-sun">☀</span><span class="toggle-icon-moon">☾</span></div>
    </button>
  </div>
</nav>

<div class="docs-layout">
  <aside class="docs-sidebar">
    <div class="sidebar-section">
      <div class="sidebar-title">fn-uns</div>
      <a href="/docs/">Overview</a>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Introduction</div>
      <a href="/docs/what-is-uns.html">What is the UNS?</a>
      <a href="/docs/why-uns.html">Why UNS Matters</a>
      <a href="/docs/why-faas.html" class="active">Why FaaS &amp; GitOps?</a>
      <a href="/docs/architecture.html">Architecture</a>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Getting Started</div>
      <a href="/docs/getting-started.html">Quick Start</a>
      <a href="/docs/fnkit-basics.html">fnkit Basics</a>
      <a href="/docs/first-deployment.html">First Deployment</a>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Components</div>
      <a href="/docs/components.html">Overview</a>
      <a href="/docs/uns-sim.html">uns-sim</a>
      <a href="/docs/uns-framework.html">uns-framework</a>
      <a href="/docs/uns-cache.html">uns-cache</a>
      <a href="/docs/uns-log.html">uns-log</a>
      <a href="/docs/uns-state.html">uns-state</a>
      <a href="/docs/uns-stoppage.html">uns-stoppage</a>
      <a href="/docs/uns-productivity.html">uns-productivity</a>
      <a href="/docs/uns-input.html">uns-input</a>
      <a href="/docs/uns-kpi.html">uns-kpi</a>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Guides</div>
      <a href="/docs/configuration.html">Configuration</a>
      <a href="/docs/manufacturing-kpis.html">Manufacturing KPIs</a>
      <a href="/docs/api-reference.html">API Reference</a>
    </div>
    <div class="sidebar-section">
      <div class="sidebar-title">Developer</div>
      <a href="/docs/code-patterns.html">Code Patterns</a>
      <a href="/docs/extending.html">Extending</a>
      <a href="/docs/database-schema.html">Database Schema</a>
    </div>
  </aside>

  <main class="docs-content">
    <h1>Why FaaS &amp; GitOps?</h1>
    <p class="page-desc">Why we use serverless functions and <code style="font-family:var(--font-mono);font-size:14px;background:var(--grey-100);padding:2px 8px;border-radius:4px;">git push</code> deployments instead of flow builders, web UIs, or monolithic platforms.</p>

    <h2>The Landscape Today</h2>

    <h3>Flow-based Tools (Node-RED, Ignition, etc.)</h3>
    <p>Drag-and-drop visual programming. Quick to prototype, but:</p>
    <table class="def-table">
      <thead><tr><th>Problem</th><th>Impact</th></tr></thead>
      <tbody>
        <tr><td>No version control</td><td>Flows live in a runtime database, not in git. Diffing, branching, rollback are impossible</td></tr>
        <tr><td>Fragile at scale</td><td>A single flow runtime handles everything. One bad node crashes the system</td></tr>
        <tr><td>Hard to test</td><td>No unit tests, no CI/CD pipeline, no automated validation</td></tr>
        <tr><td>Opaque logic</td><td>Complex flows become unreadable spaghetti. Business logic buried in node configs</td></tr>
        <tr><td>Vendor coupling</td><td>Custom nodes, proprietary function signatures, platform-specific deployment</td></tr>
      </tbody>
    </table>

    <h3>Web UI Platforms (Cloud IIoT, Low-code MES)</h3>
    <p>Browser-based configuration. Point-and-click setup. But:</p>
    <table class="def-table">
      <thead><tr><th>Problem</th><th>Impact</th></tr></thead>
      <tbody>
        <tr><td>Vendor lock-in</td><td>Your logic, data, and integrations live on someone else's platform</td></tr>
        <tr><td>Limited customisation</td><td>You can only do what the UI allows</td></tr>
        <tr><td>Subscription costs</td><td>Per-device, per-message, or per-user pricing that scales with your operation</td></tr>
        <tr><td>Data sovereignty</td><td>Your manufacturing data lives in a vendor's cloud</td></tr>
        <tr><td>Black box</td><td>You can't inspect, audit, or modify the underlying code</td></tr>
      </tbody>
    </table>

    <h2>The FaaS Approach</h2>
    <p><strong>Functions as a Service (FaaS)</strong> takes a fundamentally different approach. Each piece of logic is a small, independent function:</p>
    <div class="yaml-block">
<pre style="margin:0;font:inherit;white-space:pre">uns-state/function.go        →  Tracks machine state durations (150 lines)
uns-stoppage/index.js        →  Classifies stoppage reasons (200 lines)
uns-productivity/function.go →  Logs production runs (180 lines)
uns-kpi/function.go          →  Computes all KPIs (250 lines)</pre>
    </div>

    <p>Each function:</p>
    <table class="def-table">
      <thead><tr><th>Property</th><th>Description</th></tr></thead>
      <tbody>
        <tr><td>Does one thing</td><td>Single responsibility, easy to understand</td></tr>
        <tr><td>Standard program</td><td>Go or Node.js, no proprietary framework</td></tr>
        <tr><td>Own container</td><td>Isolated, independently scalable</td></tr>
        <tr><td>Own repo/directory</td><td>Version controlled, diffable, reviewable</td></tr>
      </tbody>
    </table>

    <h3>Code Over Configuration</h3>
    <p>Instead of clicking through a UI to define "when machine state changes, log the duration", you write:</p>
    <div class="yaml-block">
<pre style="margin:0;font:inherit;white-space:pre"><span class="yaml-key">if</span> currentState != tracked.State {
    <span class="yaml-comment">// State changed — log the completed state</span>
    duration := now.Sub(tracked.Since).Seconds()
    db.Exec(<span class="yaml-val">"INSERT INTO uns_state ..."</span>)
}</pre>
    </div>
    <p>
      This is <strong>readable</strong>, <strong>testable</strong>, <strong>reviewable</strong>, and <strong>version controlled</strong>. A new team member can read the code and understand exactly what happens.
    </p>

    <h2>Why GitOps?</h2>
    <p><strong>GitOps</strong> means git is the single source of truth for your system:</p>
    <div class="yaml-block">
<pre style="margin:0;font:inherit;white-space:pre"><span class="yaml-comment"># 1. Write or modify a function</span>
vim uns-state/function.go

<span class="yaml-comment"># 2. Test locally</span>
docker compose up -d
curl http://localhost:8080/uns-state

<span class="yaml-comment"># 3. Commit and push</span>
git add . && git commit -m "add MTBF tracking"
git push deploy main

<span class="yaml-comment"># 4. fnkit builds and deploys automatically</span></pre>
    </div>

    <h3>What GitOps Gives You</h3>
    <table class="def-table">
      <thead><tr><th>Capability</th><th>Flow-based Tools</th><th>GitOps with fnkit</th></tr></thead>
      <tbody>
        <tr><td>Version history</td><td>Limited/none</td><td>Full git log</td></tr>
        <tr><td>Branching</td><td>Not possible</td><td>Standard git branches</td></tr>
        <tr><td>Code review</td><td>Not possible</td><td>Pull requests, diffs</td></tr>
        <tr><td>Rollback</td><td>Manual/risky</td><td>git revert + push</td></tr>
        <tr><td>Audit trail</td><td>Platform-dependent</td><td>Git commits with author, date, message</td></tr>
        <tr><td>CI/CD</td><td>Platform-specific</td><td>Standard pipelines (GitHub Actions, etc.)</td></tr>
        <tr><td>Reproducibility</td><td>Export/import JSON</td><td>Clone repo, docker compose up</td></tr>
        <tr><td>Collaboration</td><td>Shared runtime (conflicts)</td><td>Branches + merge</td></tr>
      </tbody>
    </table>

    <h3>Infrastructure as Code</h3>
    <p>Every function's infrastructure is defined in its directory:</p>
    <div class="yaml-block">
<pre style="margin:0;font:inherit;white-space:pre">uns-state/
├── function.go          <span class="yaml-comment"># Business logic</span>
├── Dockerfile           <span class="yaml-comment"># Container definition</span>
├── docker-compose.yml   <span class="yaml-comment"># Service configuration</span>
├── .env.example         <span class="yaml-comment"># Environment template</span>
└── README.md            <span class="yaml-comment"># Documentation</span></pre>
    </div>
    <p>Nothing is configured through a web UI. Nothing lives only in a runtime. Everything is in the repo.</p>

    <h2>Comparison Summary</h2>
    <table class="def-table">
      <thead><tr><th>Criteria</th><th>Flow Tools</th><th>Web UI</th><th>Monolithic MES</th><th>FaaS + GitOps</th></tr></thead>
      <tbody>
        <tr><td>Version control</td><td>❌</td><td>❌</td><td>❌</td><td>✅ Git</td></tr>
        <tr><td>Code review</td><td>❌</td><td>❌</td><td>❌</td><td>✅ PRs/diffs</td></tr>
        <tr><td>Testability</td><td>❌</td><td>❌</td><td>Limited</td><td>✅ Unit/integration</td></tr>
        <tr><td>Vendor lock-in</td><td>Medium</td><td>High</td><td>High</td><td>✅ None</td></tr>
        <tr><td>Self-hosted</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td></tr>
        <tr><td>Cost</td><td>Low-medium</td><td>High</td><td>Very high</td><td>✅ Infra only</td></tr>
        <tr><td>Customisation</td><td>Medium</td><td>Low</td><td>Low</td><td>✅ Unlimited</td></tr>
      </tbody>
    </table>

    <h2>The Bottom Line</h2>
    <p>
      If your UNS implementation is a <strong>proof of concept</strong> or a <strong>small demo</strong>, flow-based tools are fine. They're quick and visual.
    </p>
    <p>
      If your UNS implementation is <strong>production infrastructure</strong> that needs to be maintained, extended, audited, and scaled by a team over years — you want code, version control, and GitOps. That's what this project demonstrates.
    </p>

    <div class="docs-nav-buttons">
      <a href="/docs/why-uns.html" class="docs-nav-btn">
        <span class="nav-label">Previous</span>
        <span class="nav-title">Why UNS Matters</span>
      </a>
      <a href="/docs/architecture.html" class="docs-nav-btn next">
        <span class="nav-label">Next</span>
        <span class="nav-title">Architecture</span>
      </a>
    </div>
  </main>
</div>

<script src="../shared.js"></script>
</body>
</html>
